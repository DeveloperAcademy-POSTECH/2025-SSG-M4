![[스크린샷 2025-05-25 오후 2.04.40.png]]
# 📌 부동소수점 개념 정리

> [!definition]
> **부동소수점(Floating Point)**  
> 소수점 위치를 고정하지 않는 방식으로 숫자를 표현함.  
> `유효숫자 × 2^지수` 형태로 구성됨. 
> (예: 1.25 × 2³)

---

## 기본 개념

- 컴퓨터는 숫자를 0과 1로 저장함
- 정수는 딱 떨어져서 표현 쉬움
- 소수는 문제가 생김 (끝이 안 나는 숫자 존재)

---

## 왜 문제가 되는가? 

- 0.1 → 이진수로 변환하면 `0.0001100110011…` (무한 반복)
- 컴퓨터는 비트 수 제한 때문에 중간에서 끊어서 저장함
- 결과적으로 정확한 값이 아니라 근사값이 됨

> [!example]
> `0.1 + 0.2 == 0.3` 으로 기대하지만, 실제 =>`0.30000000000000004` 
> > → 0.1과 0.2 자체가 정확하게 저장된 게 아님

---

## ⚙️ 부동소수점 포맷 구조

- 부호 비트 (1비트): +인지 -인지
- 지수부 (8비트 등): 소수점 위치 정보
- 가수부 (23비트 등): 유효숫자

---

## 왜 이 방식 쓰냐?

- 매우 큰 수/작은 수 모두 표현 가능해야 함  
  → 정수 방식으론 커버 안 됨
- 부동소수점 덕분에 **넓은 범위**를 표현할 수 있음

---

## 🧠 요약

- 소수는 2진수로 정확히 표현 안 되는 경우 많음
- 그래서 부동소수점은 근사해서 저장함
- 계산 오차 생기는 건 당연한 현상임
- 정밀한 비교나 계산 필요할 땐 조심해야 함

> [!tip]
> 실무에서 소수 비교할 땐 `abs(a - b) < 0.00001` 같은 식으로 오차 범위 두고 비교함

---

>[!Question]
>### 아니 그럼 음수는 ?!
>
>부동소수점에서 음수는 맨 앞의 부호 비트(sign bit) 하나로 표현함.  
이 비트가 `0`이면 양수, `1`이면 음수로 해석됨.  
예를 들어, `1.25`와 `-1.25`는 유효숫자와 지수는 같고,  
단지 부호 비트만 달라서 해석할 때만 부호가 바뀜 ! 
![[스크린샷 2025-05-25 오후 2.12.47.png]]
#### 즉, 음수 표현은 복잡한 계산 없이 첫 비트만 바꿔주는 형식



