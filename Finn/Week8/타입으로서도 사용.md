
Protocol을 타입으로 쓴다는게 사실 뭐 대단한건 아니고  그 설계도 자체를 하나의 타입으로서 취급이 가능하다는 것이다. 

### 학식 예시 
학식 - Payco / 신용카드 / P.front로만 결제가 가능하고  저 (Finn)라는 사람이 이제 학식에서 결제를 하려고합니다..! 

```swift
protocol 지곡회관결제수단 {
    func pay()
}

struct CreditCard: 지곡회관결제수단 {
    func pay() {}
}

struct Payco: 지곡회관결제수단 {
    func pay() {}
}

struct Pfront: 지곡회관결제수단 {
    func pay() {}
}

// 현금은 지곡회관결제수단 프로토콜을 안 따름
struct Cash {
    func pay(amount: Int) {}
}

// 지곡회관 결제 시스템
func 지곡회관에서결제(method: 지곡회관결제수단) {
    method.pay()
    print("결제완료")
}

let Finn: 지곡회관결제수단 = Payco()
지곡회관에서결제(method: Finn)

```
### 근데 제가 만약 지곡회관결제 protocol을 따르지않는 현금으로 결제를 시도하면? 
```swift
지곡회관에서결제(method: Cash())  // 현금으로하니까 터져버린것을 확인할 수 있다.
```
#### Error: Argument type 'Cash' does not conform to expected type '지곡회관결제수단'

### 그래서 이거 왜 쓰는가?
보니까 **타입으로서도 사용**이라고 적어놨지만 아직까지는 실제 기능을 하기보다는 좀 더 안정된 개발을 도와주는 도구로 활용되는 것을 확인할 수 있었다. 

실제로 현금들고 가서 **안돼요**하고 퇴짜맞는게 아니라, 코드 짜는 시점에 "얌마 우리 현금 결제 안돼"라고 알려주는 식이다. 

그러다가 적자에 시달리던 지곡회관이 현금도 이제 결제를 가능하게 해준다고 하면?

<img src="https://velog.velcdn.com/images/bishoe01/post/8c024843-0354-44c9-
b003-74380bd79a09/image.png" width=300/> 
그때 되어서야 그냥 Cash에 해당 프로토콜을 따르게하면 되는것이다. 아직 잘써보지도 않았지만 딱봐도 확장성이 좋아보인다.  그러면 정상적으로 현금결제가 가능해지고 에러도 뜨지않을 것이다. 
```swift
struct Cash: 지곡회관결제수단 {
    func pay() {}
}
```


### 정리
- 타입 안정성: 잘못된 타입 사용을 원천 차단
- 확장성: 새로운 결제수단 추가가 쉬움
- 명확한 의도: 어떤 것들이 가능한지 코드로 명시