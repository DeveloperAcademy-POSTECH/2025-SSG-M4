## 🔢 Swift 정수 (Integers) 완벽 정복

Swift에서 **정수(Integers)**는 소수 부분이 없는 숫자를 의미합니다. 예를 들어 `42`나 `-23`과 같은 숫자들입니다. 정수는 일상생활뿐만 아니라 프로그래밍에서도 매우 광범위하게 사용되는 기본적인 데이터 타입입니다. 이 문서에서는 Swift의 다양한 정수 타입과 그 특징, 올바른 사용법에 대해 자세히 알아봅니다.

---
### 🌟 정수의 기본 개념

#### 1. 정수란?

정수는 분수 형태가 아닌, 완전한 숫자를 나타냅니다. 여기에는 양수, 0, 그리고 음수가 포함될 수 있습니다.

#### 2. 부호 있는(Signed) 정수 vs 부호 없는(Unsigned) 정수

Swift의 정수는 크게 두 가지 종류로 나뉩니다.

- **부호 있는 정수 (Signed Integers)**:
    
    - 양수, 0, 또는 음수 값을 모두 표현할 수 있습니다.
    - 타입 이름은 주로 `Int`로 시작합니다 (예: `Int8`, `Int32`, `Int`).
    - 가장 왼쪽 비트(MSB, Most Significant Bit)를 부호 비트로 사용하여 양수와 음수를 구분합니다. (0이면 양수 또는 0, 1이면 음수).
- **부호 없는 정수 (Unsigned Integers)**:
    
    - 0 또는 양수 값만을 표현할 수 있습니다. 음수는 표현할 수 없습니다.
    - 타입 이름은 주로 `UInt`로 시작합니다 (예: `UInt8`, `UInt32`, `UInt`).
    - 모든 비트를 값의 크기를 나타내는 데 사용하므로, 같은 비트 크기의 부호 있는 정수보다 더 큰 양수 값을 표현할 수 있습니다 (음수 범위를 양수 범위로 옮겼다고 생각할 수 있습니다).

#### 3. Swift의 다양한 정수 타입

Swift는 다양한 크기의 정수 타입을 제공하여 필요에 따라 메모리 사용량과 표현 가능한 값의 범위를 선택할 수 있도록 합니다. 타입 이름은 C 언어와 유사한 명명 규칙을 따르며, Swift의 다른 타입들과 마찬가지로 **대문자로 시작**합니다.

- **8비트**: `Int8` (부호 있음), `UInt8` (부호 없음)
- **16비트**: `Int16` (부호 있음), `UInt16` (부호 없음)
- **32비트**: `Int32` (부호 있음), `UInt32` (부호 없음)
- **64비트**: `Int64` (부호 있음), `UInt64` (부호 없음)

**비트 크기의 의미**: 비트 크기는 해당 정수 타입이 메모리에서 차지하는 공간과 표현할 수 있는 값의 범위를 결정합니다. 예를 들어, 8비트 정수는 28=256개의 고유한 값을 표현할 수 있습니다.

---

### 📏 정수 범위 (Integer Bounds)

각 정수 타입이 표현할 수 있는 최소값과 최대값은 해당 타입의 `min`과 `max` 프로퍼티를 통해 쉽게 확인할 수 있습니다.

**예시 (`UInt8`의 범위 확인):**

```Swift
let minValueUInt8 = UInt8.min  // minValueUInt8는 0 이며, 타입은 UInt8 입니다.
let maxValueUInt8 = UInt8.max  // maxValueUInt8는 255 이며, 타입은 UInt8 입니다.

print("UInt8 최소값: \(minValueUInt8), 최대값: \(maxValueUInt8)")
// 출력: UInt8 최소값: 0, 최대값: 255
```

**예시 (`Int8`의 범위 확인):**

```Swift
let minValueInt8 = Int8.min    // minValueInt8는 -128 이며, 타입은 Int8 입니다.
let maxValueInt8 = Int8.max    // maxValueInt8는 127 이며, 타입은 Int8 입니다.

print("Int8 최소값: \(minValueInt8), 최대값: \(maxValueInt8)")
// 출력: Int8 최소값: -128, 최대값: 127
```

이 `min`과 `max` 프로퍼티 값은 해당 정수 타입의 값이므로, 같은 타입의 다른 값들과 함께 표현식에 사용될 수 있습니다.

**다양한 정수 타입의 범위 (일반적인 경우):**

|타입|비트 수|일반적인 최소값|일반적인 최대값|
|:--|:--|:--|:--|
|`Int8`|8|-128|127|
|`UInt8`|8|0|255|
|`Int16`|16|-32,768|32,767|
|`UInt16`|16|0|65,535|
|`Int32`|32|-2,147,483,648|2,147,483,647|
|`UInt32`|32|0|4,294,967,295|
|`Int64`|64|-9,223,372,036,854,775,808|9,223,372,036,854,775,807|
|`UInt64`|64|0|18,446,744,073,709,551,615|

---

### 🌐 플랫폼 기본 정수 타입: `Int` 와 `UInt`

대부분의 경우 코드에서 사용할 정수의 특정 비트 크기(8, 16, 32, 64비트)를 직접 명시할 필요는 없습니다. Swift는 이를 위해 **`Int`** 와 **`UInt`** 라는 두 가지 특별한 정수 타입을 제공합니다. 이 타입들의 크기는 코드가 실행되는 **현재 플랫폼의 네이티브 워드 크기(native word size)**와 동일합니다.

- **32비트 플랫폼에서**:
    - `Int`는 `Int32`와 같은 크기를 가집니다.
    - `UInt`는 `UInt32`와 같은 크기를 가집니다.
- **64비트 플랫폼에서**:
    - `Int`는 `Int64`와 같은 크기를 가집니다.
    - `UInt`는 `UInt64`와 같은 크기를 가집니다.

(참고: 현재 대부분의 Apple 기기 및 개발 환경은 64비트입니다.)

#### 1. `Int`

**일반적으로 정수 값을 사용할 때는 항상 `Int`를 사용하는 것이 권장됩니다.** 특별히 고정된 크기의 정수가 필요한 경우가 아니라면 `Int`를 사용하세요.

**왜 `Int`를 기본으로 사용해야 할까요?**

- **코드 일관성 (Code Consistency)**: 프로젝트 전체에서 `Int`를 사용하면 코드 스타일이 일관되어 가독성이 높아집니다.
- **상호 운용성 (Interoperability)**: Swift 표준 라이브러리와 대부분의 프레임워크 API는 정수 파라미터나 반환 값으로 `Int`를 사용합니다. `Int`를 사용하면 불필요한 타입 변환을 줄일 수 있습니다.
- **성능 (Performance)**: 플랫폼의 네이티브 워드 크기를 사용하므로, 해당 플랫폼에서 가장 효율적으로 처리될 수 있습니다.
- **충분한 범위**: 32비트 플랫폼에서도 `Int` (즉, `Int32`)는 -2,147,483,648부터 2,147,483,647까지의 값을 저장할 수 있으며, 이는 대부분의 일반적인 용도에 충분합니다. 64비트 플랫폼에서는 그 범위가 훨씬 더 커집니다.

**예시 (`Int` 사용):**

```Swift
var myScore: Int = 1000
let numberOfUsers: Int = 583
var year: Int = 2025

// 타입 추론으로 인해 타입 명시 생략 가능
var currentTemperature = -5 // Swift는 이를 Int로 추론
```

#### 2. `UInt`

`UInt` 역시 현재 플랫폼의 네이티브 워드 크기와 동일한 크기를 가지는 **부호 없는** 정수 타입입니다.

**`UInt`는 언제 사용해야 할까요?**

> **주의**: `UInt`는 다음과 같은 **매우 특정한 상황**에서만 사용하는 것이 좋습니다.
> 
> 1. 저장될 값이 **절대로 음수가 될 수 없음이 명확하고**, 부호 없는 타입의 특성(예: 비트 연산)이 필요한 경우.
> 2. 외부 라이브러리(특히 C 라이브러리)나 하드웨어 레지스터 등과의 상호작용 시 해당 API가 명시적으로 부호 없는 특정 크기의 정수(예: `unsigned int`에 해당하는 `UInt32` 또는 플랫폼 크기의 `UInt`)를 요구할 때.
> 3. 매우 큰 양수 값을 저장해야 하고, `Int`의 최대 양수 범위를 초과하지만 `UInt`의 범위 내에 있을 때 (이 경우에도 신중하게 고려해야 합니다).

**그럼에도 불구하고 `Int`를 더 선호하는 이유:** 값이 음수가 아니라는 것이 확실하더라도, **일반적으로는 `Int`를 사용하는 것이 더 좋습니다.**

- 서로 다른 숫자 타입 간의 불필요한 변환을 피할 수 있습니다. (예: `Int`와 `UInt`를 함께 연산하려면 반드시 한쪽을 다른 쪽 타입으로 변환해야 합니다.)
- 이는 코드의 복잡성을 줄이고, 타입 안전성(Type Safety) 및 타입 추론(Type Inference)과 관련된 잠재적 오류를 줄이는 데 도움이 됩니다.
- 대부분의 Swift API는 `Int`를 사용하므로, `UInt`를 사용하면 API 호출 시 타입 변환이 자주 필요하게 됩니다.

**예시 (`UInt` 사용 – 매우 제한적인 경우):**

```Swift
// C 라이브러리에서 받아온 이미지의 픽셀 수 (항상 양수)
// let numberOfPixels: UInt = getPixelCountFromCLibrary()

// 비트 마스크와 같은 저수준 프로그래밍
// let flags: UInt = 0b00001101
```

---
### 💡 정수 사용 시 고려사항 및 예시

- **타입 선택 가이드라인**:
    
    - 일반적인 정수 값에는 **항상 `Int`를 사용**합니다.
    - 메모리 사용량이 매우 중요하거나, 외부 소스(파일 형식, 네트워크 프로토콜, C 라이브러리)와 특정 크기의 데이터를 주고받아야 하는 경우에만 고정 크기 정수(`Int8`, `UInt16` 등)를 사용합니다.
    - `UInt`는 정말 필요한 경우가 아니라면 피하고 `Int`를 사용합니다.
- **타입이 다른 정수 간의 연산**: Swift는 타입에 매우 엄격합니다. 타입이 다른 정수끼리 직접 연산하려고 하면 컴파일 오류가 발생합니다. 명시적으로 타입을 변환해주어야 합니다.
    
    ```Swift
    let smallNumber: Int8 = 10
    let bigNumber: Int32 = 2000
    
    // let result = smallNumber + bigNumber // 오류! Int8과 Int32는 다른 타입
    let result = Int32(smallNumber) + bigNumber // smallNumber를 Int32로 변환 후 연산
    print(result) // 출력: 2010
    
    let unsignedValue: UInt = 100
    let signedValue: Int = -50
    
    // let sum = unsignedValue + signedValue // 오류! UInt와 Int는 다른 타입
    let sum = Int(unsignedValue) + signedValue // unsignedValue를 Int로 변환
    // 또는
    // let sum = unsignedValue + UInt(signedValue) // signedValue를 UInt로 변환 (값이 음수면 문제 발생 가능성!)
    print(sum) // 출력: 50
    ```
    

---
### 🔬 심화 학습: 추가 개념 및 주의점

#### 1. 정수 리터럴 (Numeric Literals)

코드에 직접 작성하는 숫자 값을 리터럴이라고 합니다. Swift 정수 리터럴은 다음과 같이 다양하게 표현할 수 있습니다.

- **10진수 (Decimal)**: 접두사 없음 (예: `let decimalInteger = 17`)
- **2진수 (Binary)**: 접두사 `0b` (예: `let binaryInteger = 0b10001`) // 17
- **8진수 (Octal)**: 접두사 `0o` (예: `let octalInteger = 0o21`) // 17
- **16진수 (Hexadecimal)**: 접두사 `0x` (예: `let hexadecimalInteger = 0x11`) // 17

가독성을 위해 숫자 사이에 밑줄(`_`)을 사용할 수 있습니다. 이 밑줄은 값에는 영향을 주지 않습니다.

```Swift
let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
```

#### 2. 정수 오버플로우 (Integer Overflow) 및 언더플로우 (Underflow)

각 정수 타입은 표현할 수 있는 값의 범위가 정해져 있습니다. 연산 결과가 이 범위를 벗어나면 **오버플로우**(최대값 초과) 또는 **언더플로우**(최소값 미만)가 발생합니다.

기본적으로 Swift는 오버플로우/언더플로우가 발생하는 연산을 허용하지 않으며, 런타임 오류를 발생시킵니다. (디버그 빌드에서)

```Swift
var willOverflow = UInt8.max // 255
// willOverflow = willOverflow + 1 // 오류 발생! (UInt8의 최대값은 255)
```

의도적으로 오버플로우/언더플로우를 허용하고 싶거나, 오버플로우 발생 시 특정 동작(예: 값 자르기)을 원할 경우, Swift는 특별한 오버플로우 연산자(`&+`, `&-`, `&*` 등)를 제공합니다. 이는 고급 주제이므로 주의해서 사용해야 합니다.

---
### 🚀 연관 학습 내용

정수에 대한 이해를 바탕으로 다음과 같은 주제들을 학습하면 Swift의 숫자 다루기에 대한 이해를 더욱 넓힐 수 있습니다.

1. **타입 변환 (Type Conversion / Casting)**:
    
    - 정수 타입 간 변환 (`Int(someUInt8Value)`)
    - 정수와 부동소수점 수 간 변환 (`Double(someIntValue)`)
2. **부동소수점 수 (Floating-Point Numbers)**:
    
    - `Float` 및 `Double` 타입 (소수점을 포함하는 숫자)
    - 정수와의 연산 시 주의점 및 타입 변환.
3. **산술 연산자 (Arithmetic Operators)**:
    
    - 덧셈(`+`), 뺄셈(`-`), 곱셈(`*`), 나눗셈(`/`), 나머지(`%`) 연산자.
    - 복합 할당 연산자 (`+=`, `-=`, `*=`, `/=`, `%=`).
4. **비트 연산자 (Bitwise Operators)**:
    
    - `~`, `&`, `|`, `^`, `<<`, `>>` (저수준 프로그래밍이나 특정 알고리즘에 사용)
5. **Swift의 타입 안전성 (Type Safety)**:
    
    - Swift가 어떻게 엄격한 타입 시스템을 통해 프로그래머의 실수를 줄이는지 이해.

Swift에서 `Int`를 기본으로 사용하는 습관은 코드의 안정성과 호환성을 높이는 좋은 시작입니다. 다양한 정수 타입의 특징을 이해하고 상황에 맞게 적절히 활용해 보세요!